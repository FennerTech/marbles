<!-- -----------------------------------------------
Automatic Marbles v1.0
(c) 2025 Marco Fenner

Urheberrechtlich gesch√ºtzt.
Kopieren erlaubt.
Ver√§ndern nur mit Namensnennung des Autors ;-)
Danke und Viel Spa√ü!
------------------------------------------------ -->
<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mein Browsergame</title>
    <link rel="icon" href="favicon.ico" type="image/x-icon">
    <link rel="shortcut icon" href="favicon.ico" type="image/x-icon">
    <link rel="apple-touch-icon" href="apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="favicon-16x16.png">

    <meta name="description" content="Automatic Marbles v1.0 - Ein faszinierendes Zero-Player-Game von Marco Fenner. Beobachten Sie, wie Murmeln ihren Weg zum Ziel finden und sammeln Sie Punkte.">
    <meta name="keywords" content="Zero-Player Game, Automatic Marbles, Murmelspiel, Online Spiel, Browsergame, Marco Fenner, kostenlos, entspannend, Simulation">
    <meta name="author" content="Marco Fenner">
    <meta name="robots" content="index, follow"> <link rel="canonical" href="https://fennertech.github.io/marbles/"> <meta property="og:title" content="Automatic Marbles v1.0 - Das Zero-Player-Game">
    <meta property="og:description" content="Beobachten Sie, wie Murmeln ihren Weg zum Ziel finden und sammeln Sie Punkte in diesem einzigartigen Zero-Player-Game.">
    <meta property="og:url" content="https://fennertech.github.io/marbles/">
    <meta property="og:type" content="website">
    <meta property="og:image" content="https://fennertech.github.io/marbles/social-share-image.png"> <meta property="og:locale" content="de_DE">

    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="Automatic Marbles v1.0 - Das Zero-Player-Game">
    <meta name="twitter:description" content="Beobachten Sie, wie Murmeln ihren Weg zum Ziel finden und sammeln Sie Punkte in diesem einzigartigen Zero-Player-Game.">
    <meta name="twitter:image" content="https://fennertech.github.io/marbles/social-share-image.png"> <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Grundlegende Stile f√ºr den gesamten Viewport */
        html, body {
            margin: 0;
            padding: 0.5rem; /* p-2: F√ºgt einen inneren Abstand hinzu, um die R√§nder freizuhalten */
            overflow: hidden; /* Verhindert Scrollbalken */
            height: 100%; /* Nimmt die volle volle H√∂he des Viewports ein */
            font-family: 'Inter', sans-serif; /* Standard-Schriftart */
            background-color: #333; /* Dunkelgrauer Hintergrund */
            color: #fff; /* Wei√üe Schriftfarbe */
            box-sizing: border-box; /* Stellt sicher, dass Padding zur Gesamtgr√∂√üe geh√∂rt */
        }

        /* Sicherstellen, dass der Hauptcontainer die volle H√∂he einnimmt */
        #game-container {
            height: 100%;
            display: flex;
            height: 100%; /* Jetzt 100% der verf√ºgbaren H√∂he nach Padding im Body */
            width: 100%; /* Jetzt 100% der verf√ºgbaren Breite nach Padding im Body */
        }

        /* Info-Bereich (linkes Viertel) */
        #info-area {
            width: 25%; /* w-1/4 */
            padding: 1rem; /* p-4 */
            border: 1px solid #4b5563; /* border border-gray-600 */
            border-radius: 0.5rem; /* rounded-lg */
            display: flex; /* flex */
            flex-direction: column; /* flex-col */
            justify-content: space-between; /* justify-between */
            margin-right: 0.5rem; /* Kleiner Abstand zum Spielfeld */
        }

        /* Titel des Spiels */
        #info-area h2 {
            font-size: 2.25rem; /* text-4xl */
            font-weight: 700; /* font-bold */
            margin-bottom: 0.5rem; /* mb-2 */
        }

        /* Spielbeschreibung und Link */
        #info-area p.text-lg {
            font-size: 1.125rem; /* text-lg */
            color: #d1d5db; /* text-gray-300 */
            margin-bottom: 1rem; /* mb-4 */
        }

        #info-area a {
            color: #60a5fa; /* text-blue-400 */
            text-decoration: underline; /* underline */
        }

        #info-area a:hover {
            color: #93c5fd; /* hover:text-blue-300 */
        }

        /* Flex-Grow f√ºr den mittleren Bereich */
        #info-area .flex-grow {
            flex-grow: 1; /* flex-grow */
        }

        /* Gesamtpunktzahl */
        #score-display {
            font-size: 2.25rem; /* text-4xl */
            font-weight: 800; /* font-extrabold */
            text-align: center; /* text-center */
            margin-top: 1rem; /* mt-4 */
            color: #fcd34d; /* text-yellow-300 */
        }

        /* Errungenschaften Bereich */
        #achievements-area {
            margin-top: 2rem; /* mt-8 */
            margin-bottom: 2rem; /* mb-8 */
        }

        #achievements-area h3 {
            font-size: 1.25rem; /* text-xl */
            font-weight: 600; /* font-semibold */
            margin-bottom: 0.5rem; /* mb-2 */
        }

        #achievements-area table {
            width: 100%; /* w-full */
            text-align: left; /* text-left */
            font-size: 0.875rem; /* text-sm */
        }

        #achievements-area thead tr {
            border-bottom: 1px solid #4b5563; /* border-b border-gray-600 */
        }

        #achievements-area th {
            padding-top: 0.25rem; /* py-1 */
            padding-bottom: 0.25rem; /* py-1 */
        }

        #achievements-area td {
            padding-top: 0.25rem; /* py-1 */
            padding-bottom: 0.25rem; /* py-1 */
        }

        #achievements-area td.pr-2 {
            padding-right: 0.5rem; /* pr-2 */
        }

        #achievements-area .text-green-400 {
            color: #4ade80; /* text-green-400 */
        }

        #achievements-area .text-gray-500 {
            color: #6b7280; /* text-gray-500 */
        }

        /* Buttons Container */
        #button-container { /* Spezifischer Selektor f√ºr den Button-Container */
            margin-top: 1rem; /* mt-4 */
            display: flex; /* flex */
            justify-content: center; /* justify-content: center; f√ºr horizontale Zentrierung */
            gap: 0.5rem; /* space-x-2 */
            width: 100%; /* Sicherstellen, dass der Container die volle Breite einnimmt */
        }

        /* Buttons */
        #button-container button {
            font-weight: 700; /* font-bold */
            padding: 0.5rem 1rem; /* py-2 px-4 - Etwas kleiner als vorher */
            font-size: 1rem; /* text-base - Etwas kleiner als vorher */
            border-radius: 0.5rem; /* rounded-lg */
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1); /* shadow-md */
            color: #fff; /* text-white */
            transition: background-color 0.15s ease-in-out, opacity 0.15s ease-in-out; /* F√ºr Hover-Effekt und Deaktivierung */
            cursor: pointer; /* Zeigt an, dass es klickbar ist */
            flex-grow: 0; /* Buttons f√ºllen den verf√ºgbaren Platz aus */
            text-align: center; /* Text zentrieren */
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5); /* Leichter Textschatten f√ºr bessere Lesbarkeit */
            letter-spacing: 0.05em; /* Leichter Zeichenabstand */
        }

        /* Deaktivierter Button Stil */
        #button-container button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        /* Copyright-Text */
        #info-area > div:last-of-type > p { /* Spezifischer Selektor f√ºr den Copyright-Text */
            margin-top: 0.5rem; /* Abstand auf einen Zeilenumbruch reduziert */
            text-align: center; /* text-center */
            font-size: 0.875rem; /* text-sm */
            color: #9ca3af; /* text-gray-400 */
        }

        /* Besucherz√§hler-Text */
        #visitor-counter-area {
            margin-top: 1rem; /* Abstand √ºber dem Z√§hler */
            margin-bottom: 0.5rem; /* Abstand unter dem Z√§hler auf einen Zeilenumbruch reduziert */
            font-size: 0.875rem; /* text-sm */
            color: #9ca3af; /* text-gray-400 */
            text-align: center; /* Zentriert den Textinhalt */
            white-space: nowrap; /* Verhindert Zeilenumbruch */
        }

        #visitor-counter-area span {
            /* Sicherstellen, dass die Spans inline sind und keine unerw√ºnschten Abst√§nde haben */
            display: inline;
            margin: 0 0.25rem; /* Kleiner horizontaler Abstand zwischen den Werten */
            padding: 0;
        }

        /* Spielfeld */
        #game-field {
            width: 75%; /* w-3/4 */
            height: 100%; /* h-full */
            background-color: #374151; /* bg-gray-700 */
            border-radius: 0.5rem; /* rounded-lg */
            box-sizing: border-box; /* Stellt sicher, dass Padding zur Gesamtgr√∂√üe geh√∂rt */
            margin-left: 0.5rem; /* Kleiner Abstand zum Info-Bereich */
        }

        /* Allgemeine Modal Stile */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000; /* Sicherstellen, dass es √ºber allem liegt */
        }

        .modal-content {
            background-color: #374151; /* bg-gray-700 */
            padding: 2rem; /* p-8 */
            border-radius: 0.5rem; /* rounded-lg */
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05); /* shadow-xl */
            text-align: center;
            max-width: 600px; /* Breiter f√ºr Impressum */
            color: #fff;
            position: relative; /* F√ºr absolute Positionierung des Close-Buttons */
            max-height: 90vh; /* Maximale H√∂he des Modals */
            display: flex; /* Flexbox f√ºr Inhalt und Footer */
            flex-direction: column;
        }

        .modal-content h3 {
            font-size: 1.5rem; /* text-2xl */
            font-weight: 700; /* font-bold */
            margin-bottom: 1rem; /* mb-4 */
            text-align: left;
        }

        .modal-content p {
            font-size: 1rem; /* text-base */
            margin-bottom: 1rem; /* mb-4 */
            text-align: left;
            line-height: 1.5;
        }

        .modal-content .modal-text-content {
            overflow-y: auto; /* Scrollbalken f√ºr Inhalt */
            flex-grow: 1; /* Nimmt verf√ºgbaren Platz ein */
            padding-right: 1rem; /* Platz f√ºr Scrollbar */
            margin-bottom: 1rem; /* Abstand zum Footer */
        }
        
        .modal-content .modal-text-content strong {
            color: #fcd34d; /* Hellgelb f√ºr √úberschriften im Impressum */
        }

        .modal-buttons {
            display: flex;
            justify-content: center;
            gap: 1rem; /* space-x-4 */
            margin-top: 1rem; /* Abstand zum Inhalt */
            flex-shrink: 0; /* Verhindert Schrumpfen des Buttons */
        }

        /* Modal Buttons - Vergr√∂√üert und lesbarer */
        .modal-buttons button, .modal-close-button {
            font-weight: 700; /* font-bold */
            padding: 0.75rem 1.5rem; /* py-3 px-6 - Vergr√∂√üert */
            font-size: 1.125rem; /* text-lg - Vergr√∂√üert */
            border-radius: 0.5rem; /* rounded-lg */
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1); /* shadow-md */
            color: #fff; /* text-white */
            transition: background-color 0.15s ease-in-out; /* F√ºr Hover-Effekt */
            cursor: pointer; /* Zeigt an, dass es klickbar ist */
            flex-grow: 0; /* Nicht flex-grow:1, damit sie nicht den ganzen Platz einnehmen */
            text-align: center; /* Text zentrieren */
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5); /* Leichter Textschatten f√ºr bessere Lesbarkeit */
            letter-spacing: 0.05em; /* Leichter Zeichenabstand */
        }

        .modal-close-button {
            position: absolute;
            top: 0.5rem;
            right: 0.5rem;
            background: none;
            border: none;
            font-size: 1.5rem;
            color: #fff;
            cursor: pointer;
            padding: 0.25rem 0.5rem;
            line-height: 1;
            box-shadow: none;
        }
        .modal-close-button:hover {
            color: #ef4444; /* Rot beim Hover */
        }

        /* Klasse zum Ein-/Ausblenden */
        .hidden {
            display: none !important; /* Wichtig, um display:flex zu √ºberschreiben */
        }
    </style>
</head>
<body class="bg-gray-800 text-white">
    <script language="JavaScript" src="https://www.besucherzaehler-kostenlos.de/js/counter.js.php?count=1&id=fennertech.github.iomarbles&start=0&design=6"></script>

    <div id="game-container">
        <div id="info-area">
            <h2>Automatic Marbles v1.0</h2>
            <p>
                Ein neues Zero-Player-Game<br>
                vom <a href="mailto:datenschrauber@posteo.de">Datenschrauber</a>
            </p>
            <div class="flex-grow">
                <p id="score-display">0</p>

                <div id="achievements-area">
                    <h3>Errungenschaften</h3>
                    <table>
                        <thead>
                            <tr>
                                <th>Ziel</th>
                                <th>Erreicht am</th>
                            </tr>
                        </thead>
                        <tbody id="achievements-list">
                            </tbody>
                    </table>
                </div>
            </div>

            <div id="button-container">
                <button id="reset-button" class="bg-red-600">
                    X
                </button>
                <button id="impressum-button" class="bg-blue-600">
                    i
                </button>
                <button id="new-marble-button" class="bg-green-600">
                    Neue Murmel!
                </button>
            </div>

            <div id="visitor-counter-area">
                <span>O: <span class="BZonline"></span></span> |
                <span>H: <span class="BZheute"></span></span> |
                <span>G: <span class="BZgestern"></span></span> |
                <span>T: <span class="BZgesamt"></span></span> |
                <span>S: <span class="BZseit"></span></span>
            </div>

            <div>
                <p>(c) 2025 ff. Marco Fenner</p>
            </div>
        </div>

        <div id="game-field">
            </div>
    </div>

    <div id="reset-modal" class="modal-overlay hidden">
        <div class="modal-content">
            <p>M√∂chten Sie den Spielstand und alle Errungenschaften wirklich zur√ºcksetzen?</p>
            <div class="modal-buttons">
                <button id="reset-confirm-yes" class="bg-red-600">Ja</button>
                <button id="reset-confirm-no" class="bg-blue-600">Nein</button>
            </div>
        </div>
    </div>

    <div id="impressum-modal" class="modal-overlay hidden">
        <div class="modal-content">
            <button id="impressum-close" class="modal-close-button">X</button>
            <h3>Informationen zum Spiel / Impressum</h3>
            <div class="modal-text-content">
                <p><strong>Angaben gem√§√ü ¬ß 5 TMG</strong><br>
                Betreiber der Website:<br>
                Marco Fenner<br>
                Wiardastra√üe 19<br>
                26603 Aurich<br>
                Deutschland</p>

                <p><strong>Kontakt:</strong><br>
                E-Mail: <a href="mailto:datenschrauber@posteo.de" class="text-blue-400 hover:text-blue-300 underline">datenschrauber@posteo.de</a><br>
                Telefon: +49 1573 004 2105</p>

                <p>Vielen Dank f√ºr den Besuch meiner Website.<br>
                Wenn Sie Ihnen gefallen hat, w√ºrde ich mich √ºber eine kurze Nachricht sehr freuen. üòä</p>

                <p><strong>Haftungsausschluss:</strong></p>
                <p><strong>Haftung f√ºr Inhalte</strong><br>
                Als Diensteanbieter bin ich gem√§√ü ¬ß 7 Abs.1 TMG f√ºr eigene Inhalte auf diesen Seiten nach den allgemeinen Gesetzen verantwortlich. Nach ¬ß¬ß 8 bis 10 TMG bin ich als Diensteanbieter jedoch nicht verpflichtet, √ºbermittelte oder gespeicherte fremde Informationen zu √ºberwachen oder nach Umst√§nden zu forschen, die auf eine rechtswidrige T√§tigkeit hinweisen. Verpflichtungen zur Entfernung oder Sperrung der Nutzung von Informationen nach den allgemeinen Gesetzen bleiben hiervon unber√ºhrt. Eine diesbez√ºgliche Haftung ist jedoch erst ab dem Zeitpunkt der Kenntnis einer konkreten Rechtsverletzung m√∂glich. Bei Bekanntwerden von entsprechenden Rechtsverletzungen werde ich diese Inhalte umgehend entfernen.</p>

                <p><strong>Haftung f√ºr Links</strong><br>
                Mein Angebot enth√§lt Links zu externen Websites Dritter, auf deren Inhalte ich keinen Einfluss habe. Deshalb kann ich f√ºr diese fremden Inhalte auch keine Gew√§hr √ºbernehmen. F√ºr die Inhalte der verlinkten Seiten ist stets der jeweilige Anbieter oder Betreiber der Seiten verantwortlich. Die verlinkten Seiten wurden zum Zeitpunkt der Verlinkung auf m√∂gliche Rechtsverst√∂√üe √ºberpr√ºft. Rechtswidrige Inhalte waren zum Zeitpunkt der Verlinkung nicht erkennbar. Eine permanente inhaltliche Kontrolle der verlinkten Seiten ist jedoch ohne konkrete Anhaltspunkte einer Rechtsverletzung nicht zumutbar. Bei Bekanntwerden von Rechtsverletzungen werde ich derartige Links umgehend entfernen.</p>

                <p><strong>Urheberrecht</strong><br>
                Die durch die Seitenbetreiber erstellten Inhalte und Werke auf diesen Seiten unterliegen dem deutschen Urheberrecht. Die Vervielf√§ltigung, Bearbeitung, Verbreitung und jede Art der Verwertung au√üerhalb der Grenzen des Urheberrechtes bed√ºrfen der schriftlichen Zustimmung des jeweiligen Autors bzw. Erstellers. Downloads und Kopien dieser Seite sind nur f√ºr den privaten, nicht kommerziellen Gebrauch gestattet. Soweit die Inhalte auf dieser Seite nicht vom Betreiber erstellt wurden, werden die Urheberrechte Dritter beachtet. Insbesondere werden Inhalte Dritter als solche gekennzeichnet. Sollten Sie trotzdem auf eine Urheberrechtsverletzung aufmerksam werden, bitte ich um einen entsprechenden Hinweis. Bei Bekanntwerden von Rechtsverletzungen werde ich diese Inhalte umgehend entfernen.</p>

                <p><strong>Datenschutz:</strong><br>
                Die Nutzung meiner Webseite ist in der Regel ohne Angabe personenbezogener Daten m√∂glich. Soweit auf meinen Seiten personenbezogene Daten (beispielsweise Name, Anschrift oder E-Mail-Adressen) erhoben werden, erfolgt dies, soweit m√∂glich, stets auf freiwilliger Basis. Diese Daten werden ohne Ihre ausdr√ºckliche Zustimmung nicht an Dritte weitergegeben. Ich weise darauf hin, dass die Daten√ºbertragung im Internet (z.B. bei der Kommunikation per E-Mail) Sicherheitsl√ºcken aufweisen kann. Ein l√ºckenloser Schutz der Daten vor dem Zugriff durch Dritte ist nicht m√∂glich.</p>

                <p><strong>Besucherz√§hler von besucherzaehler-kostenlos.de</strong><br>
                Diese Webseite verwendet einen externen Z√§hler, um die Anzahl der Webseitenaufrufe zu erfassen. Daf√ºr wird ein Java-Script von einer externe Webseite geladen. Der Server von besucherzaehler-kostenlos.de speichert die IP-Adresse des Zugriffs anonymisiert und zeitlich begrenzt in einer LOG-Datei ab. Diese wird regelm√§√üig unwiderruflich gel√∂scht.<br>
                Um die korrekte Funktionsweise des Z√§hlers zu gew√§hrleisten, speichert der Besucherz√§hler zudem einen sogenannten Session-Cookie auf dem Computer des Besuchers ab. Dieser wird in der Regel vom Browser gel√∂scht, sobald er geschlossen wird. In diesem Cookie werden keine pers√∂nlichen Informationen gespeichert. Er enth√§lt lediglich die Information der aufgerufenen Domain, sowie einen boolschen Tag (true/false), um den Besucher als bereits gez√§hlt zu markieren.<br>
                Es werden auch dar√ºberhinaus keine pers√∂nlichen oder personenbezogenen Daten vom Besucherz√§hler erhoben. Eine Nachverfolgung oder Zuordnung der Zugriffe ist zu keiner Zeit m√∂glich. Ein besonderer Dank geht an www.howtodocentral.com, durch dessen Unterst√ºtzung dieser kostenlose Service erst m√∂glich gemacht wird.</p>

                <p><strong>Einsehbarkeit des Quellcodes:</strong><br>
                Der Quellcode dieser Seite ist vollst√§ndig f√ºr jedermann einsehbar.</p>

                <p><strong>Besucherz√§hler-Abk√ºrzungen:</strong><br>
                O = Besucher aktuell online<br>
                H = Besucher heute<br>
                G = Besucher gestern<br>
                T = Besucher gesamt<br>
                S = Seit - Beginn der Z√§hlung</p>
            </div>
            <div class="modal-buttons">
                <button id="impressum-ok" class="bg-blue-600">Ok</button>
            </div>
        </div>
    </div>

    <div id="cookie-consent-modal" class="modal-overlay hidden">
        <div class="modal-content">
            <h3>Cookie-Hinweis</h3>
            <div class="modal-text-content">
                <p>Diese Website verwendet Cookies, um die Funktionalit√§t zu gew√§hrleisten und den Besucherz√§hler zu betreiben. Mit der Nutzung der Website stimmen Sie der Verwendung von Cookies zu.</p>
                <p>Weitere Informationen finden Sie in unserem <a href="#" id="cookie-impressum-link" class="text-blue-400 hover:text-blue-300 underline">Impressum</a>.</p>
            </div>
            <div class="modal-buttons">
                <button id="cookie-consent-ok" class="bg-blue-600">Ok</button>
            </div>
        </div>
    </div>

    <script>
        // Referenz zum Spielfeld-Container und Erstellung des Canvas-Elements
        const gameField = document.getElementById('game-field');
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        // Vorhandenen Platzhalter-Inhalt entfernen und Canvas hinzuf√ºgen
        gameField.innerHTML = ''; // Sicherstellen, dass keine alten Inhalte st√∂ren
        gameField.appendChild(canvas);

        // Spielvariablen
        let marbles = []; // Array f√ºr alle aktiven Murmeln
        let lastSpawnTime = Date.now(); // Zeitpunkt der letzten Murmel-Erzeugung
        let nextSpawnInterval = getRandomInt(5000, 15000); // Zuf√§lliges Intervall f√ºr die n√§chste Murmel (5 bis 15 Sekunden)

        const MARBLE_RADIUS = 10; // Radius der Murmeln in Pixeln

        // Eingang und Ausgang Positionen (relativ zum Canvas)
        let entranceX, entranceY, exitX, exitY;

        // Global variables for achievements
        let achievements = [];
        // Definierte Schwellenwerte f√ºr Errungenschaften
        // Die letzte Errungenschaft (2.000.000) ist basierend auf ca. 5 Jahren Spielzeit bei 8h/Tag
        const achievementThresholds = [
            1, 10, 100, 500, 1000, 2500, 5000, 10000, 25000, 50000,
            100000, 250000, 500000, 1000000, 1500000, 2000000
        ];

        /**
         * Aktualisiert die Positionen von Eingang und Ausgang basierend auf der aktuellen Canvas-Gr√∂√üe.
         * Wird bei der Initialisierung und bei jeder Gr√∂√üen√§nderung des Fensters aufgerufen.
         */
        function setEntranceExitPositions() {
            // Eingang: Oben links, mit etwas Abstand vom Rand
            entranceX = MARBLE_RADIUS * 2;
            entranceY = MARBLE_RADIUS * 2;
            // Ausgang: Unten rechts, mit etwas Abstand vom Rand
            exitX = canvas.width - MARBLE_RADIUS * 2;
            exitY = canvas.height - MARBLE_RADIUS * 2;
        }

        /**
         * Passt die Gr√∂√üe des Canvas-Elements an die Gr√∂√üe seines Elternelements an.
         * Ruft anschlie√üend `setEntranceExitPositions` auf, um die Spielbereiche neu zu positionieren.
         * Und `drawGame`, um den Inhalt neu zu zeichnen.
         */
        function resizeCanvas() {
            canvas.width = gameField.clientWidth;
            canvas.height = gameField.clientHeight;
            setEntranceExitPositions(); // Positionen nach Gr√∂√üen√§nderung anpassen
            drawGame(); // Spielinhalt neu zeichnen
        }

        // Event Listener f√ºr Gr√∂√üen√§nderung des Fensters, um das Canvas anzupassen
        window.addEventListener('resize', resizeCanvas);

        /**
         * Generiert eine zuf√§llige Ganzzahl zwischen min (inklusiv) und max (inklusiv).
         * @param {number} min - Der minimale Wert.
         * @param {number} max - Der maximale Wert.
         * @returns {number} Eine zuf√§llige Ganzzahl.
         */
        function getRandomInt(min, max) {
            min = Math.ceil(min);
            max = Math.floor(max);
            return Math.floor(Math.random() * (max - min + 1)) + min;
        }

        /**
         * Repr√§sentiert eine einzelne Murmel im Spiel.
         */
        class Marble {
            /**
             * Erstellt eine neue Murmel.
             * @param {number} id - Eine eindeutige ID f√ºr die Murmel.
             */
            constructor(id) {
                this.id = id;
                this.x = entranceX; // Startposition X (Eingang)
                this.y = entranceY; // Startposition Y (Eingang)
                this.radius = MARBLE_RADIUS;
                // Zuf√§llige, lebendige Farbe, die sich gut vom Hintergrund abhebt
                this.color = `hsl(${Math.random() * 360}, 70%, 60%)`;
                this.spawnTime = Date.now(); // Zeitpunkt der Erzeugung
                this.reachedExitTime = null; // Zeitpunkt, zu dem die Murmel den Ausgang erreicht hat (null, wenn nicht erreicht)
                this.markedForRemoval = false; // Markierung, ob die Murmel entfernt werden soll

                // Zuf√§llige Zielzeit zwischen 10 und 60 Sekunden (10000ms bis 60000ms)
                const targetTimeMs = getRandomInt(10000, 60000);

                // Berechne die direkte Distanz vom Eingang zum Ausgang
                const directDistance = Math.hypot(exitX - entranceX, exitY - entranceY);

                // Berechne die durchschnittliche Geschwindigkeit, die ben√∂tigt wird, um die direkte Distanz in targetTimeMs zu √ºberwinden
                this.targetSpeed = directDistance / targetTimeMs;

                // Sicherstellen einer Mindestgeschwindigkeit, damit die Murmel immer sichtbar ist
                const MIN_MARBLE_SPEED = 0.05; // 50 Pixel pro Sekunde
                if (this.targetSpeed < MIN_MARBLE_SPEED) {
                    this.targetSpeed = MIN_MARBLE_SPEED;
                }

                // Initialisiere Geschwindigkeiten mit einer Tendenz zum Ausgang und gro√üer zuf√§lliger Abweichung
                const initialAngleToExit = Math.atan2(exitY - entranceY, exitX - entranceX);
                // Erlaube eine sehr breite initiale Winkelabweichung f√ºr zuf√§llige Pfade
                const initialRandomAngleOffset = (Math.random() * 2 - 1) * Math.PI; // +/- 180 Grad
                const initialDesiredAngle = initialAngleToExit + initialRandomAngleOffset;

                this.vx = Math.cos(initialDesiredAngle) * this.targetSpeed;
                this.vy = Math.sin(initialDesiredAngle) * this.targetSpeed;

                // Steuerungsst√§rke: Wie stark die Murmel versucht, ihren Pfad zum Ausgang zu korrigieren
                // Ein leicht erh√∂hter Wert, um die Zielerreichung innerhalb der Zeit zu garantieren.
                this.steeringStrength = 0.001;
            }

            /**
             * Zeichnet die Murmel auf dem Canvas.
             * @param {CanvasRenderingContext2D} ctx - Der 2D-Rendering-Kontext des Canvas.
             */
            draw(ctx) {
                // Hauptk√∂rper der Murmel zeichnen
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fillStyle = this.color;
                ctx.fill();
                ctx.strokeStyle = '#fff'; // Wei√üer Rand
                ctx.lineWidth = 1;
                ctx.stroke();
                ctx.closePath();

                // Lichtpunkt f√ºr 3D-Effekt zeichnen
                ctx.beginPath();
                const lightSpotRadius = this.radius * 0.3; // Kleinerer Radius f√ºr den Lichtpunkt
                const lightSpotX = this.x - this.radius * 0.4; // Versatz von der Mitte (oben links)
                const lightSpotY = this.y - this.radius * 0.4; // Versatz von der Mitte (oben links)
                ctx.arc(lightSpotX, lightSpotY, lightSpotRadius, 0, Math.PI * 2);
                ctx.fillStyle = 'rgba(255, 255, 255, 0.8)'; // Halbtransparentes Wei√ü
                ctx.fill();
                ctx.closePath();
            }

            /**
             * Aktualisiert den Zustand der Murmel (Position, Status).
             * @param {number} deltaTime - Die seit dem letzten Update vergangene Zeit in Millisekunden.
             */
            update(deltaTime) {
                // Wenn die Murmel den Ausgang erreicht hat, wird sie sofort entfernt
                if (this.reachedExitTime) {
                    this.markedForRemoval = true; // Sofort zum Entfernen markieren
                    return;
                }

                // Position aktualisieren
                this.x += this.vx * deltaTime;
                this.y += this.vy * deltaTime;

                // Kollisionserkennung mit den R√§ndern des Canvas und Abprallen
                // Die Murmel soll das Spielfeld auf keinen Fall verlassen.
                if (this.x + this.radius > canvas.width) {
                    this.x = canvas.width - this.radius;
                    this.vx *= -1; // Richtung umkehren
                    // Zus√§tzliche zuf√§llige Abweichung beim Abprallen f√ºr unvorhersehbare Wege
                    this.vx += (Math.random() - 0.5) * this.targetSpeed * 0.5;
                } else if (this.x - this.radius < 0) {
                    this.x = this.radius;
                    this.vx *= -1; // Richtung umkehren
                    this.vx += (Math.random() - 0.5) * this.targetSpeed * 0.5;
                }

                if (this.y + this.radius > canvas.height) {
                    this.y = canvas.height - this.radius;
                    this.vy *= -1; // Richtung umkehren
                    this.vy += (Math.random() - 0.5) * this.targetSpeed * 0.5;
                } else if (this.y - this.radius < 0) {
                    this.y = this.radius;
                    this.vy *= -1; // Richtung umkehren
                    this.vy += (Math.random() - 0.5) * this.targetSpeed * 0.5;
                }

                // Sanfte Lenkung zum Ausgang, um sicherzustellen, dass das Ziel erreicht wird.
                // Diese Logik wird nur angewendet, wenn die Murmel nicht bereits sehr nah am Ausgang ist.
                const distanceToExit = Math.hypot(this.x - exitX, this.y - exitY);
                if (distanceToExit > this.radius * 2) { // Wenn noch nicht nah genug am Ausgang
                    const angleToExit = Math.atan2(exitY - this.y, exitX - this.x);

                    // Nudge aktuelle Geschwindigkeit in Richtung des Ausgangs
                    const currentAngle = Math.atan2(this.vy, this.vx);
                    const angleDifference = angleToExit - currentAngle;
                    // Normalisiere angleDifference, um zwischen -PI und PI zu liegen
                    const normalizedAngleDifference = Math.atan2(Math.sin(angleDifference), Math.cos(angleDifference));

                    // Wende Lenkraft als Winkelanpassung an
                    const steeringAngle = currentAngle + normalizedAngleDifference * this.steeringStrength;

                    // Wende zuf√§llige Winkelst√∂rung an f√ºr unregelm√§√üigere Pfade
                    const randomAngularPerturbation = (Math.random() * 2 - 1) * (Math.PI / 32); // +/- 5.6 Grad
                    const finalAngle = steeringAngle + randomAngularPerturbation;

                    // Aktualisiere Geschwindigkeiten, wobei die Zielgeschwindigkeit beibehalten wird
                    this.vx = Math.cos(finalAngle) * this.targetSpeed;
                    this.vy = Math.sin(finalAngle) * this.targetSpeed;

                    // Sicherstellen, dass die Murmel tendenziell nach rechts und unten rollt
                    // Dies bedeutet, dass, wenn die Murmel links vom Ausgang ist, ihre vx positiv sein sollte.
                    // Wenn sie oberhalb des Ausgangs ist, sollte ihre vy positiv sein.
                    // Dies ist die Interpretation von "niemals r√ºckw√§rts rollen" in Kombination mit zuf√§lligen Pfaden.
                    if (this.x < exitX && this.vx < 0) this.vx = 0; // Verhindert Bewegung nach links, wenn Ausgang rechts ist
                    if (this.y < exitY && this.vy < 0) this.vy = 0; // Verhindert Bewegung nach oben, wenn Ausgang unten ist

                } else {
                    // Wenn die Murmel sehr nah am Ausgang ist, richte sie direkt auf den Ausgang aus
                    // um ein sicheres Erreichen zu gew√§hrleisten und die Zeitvorgabe einzuhalten.
                    this.vx = (exitX - this.x) / (deltaTime * 20); // Schnellere Bewegung zum Ziel
                    this.vy = (exitY - this.y) / (deltaTime * 20);
                }

                // √úberpr√ºfen, ob die Murmel den Ausgangsbereich erreicht hat
                if (distanceToExit < this.radius * 1.5 && !this.reachedExitTime) { // Etwas kleinerer Radius f√ºr pr√§zises Erreichen
                    this.reachedExitTime = Date.now(); // Zeitpunkt des Erreichens speichern
                    updateScore(currentScore + 1); // Punktestand erh√∂hen
                    this.markedForRemoval = true; // Sofort zum Entfernen markieren
                }
            }
        }

        /**
         * Zeichnet den gesamten Spielzustand auf dem Canvas (Hintergrund, Eingang, Ausgang, Murmeln).
         */
        function drawGame() {
            ctx.clearRect(0, 0, canvas.width, canvas.height); // Canvas leeren

            // Eingangsbereich zeichnen (ohne Beschriftung)
            ctx.fillStyle = 'rgba(0, 255, 0, 0.5)'; // Gr√ºn, halbtransparent
            ctx.fillRect(entranceX - MARBLE_RADIUS, entranceY - MARBLE_RADIUS, MARBLE_RADIUS * 2, MARBLE_RADIUS * 2);

            // Ausgangsbereich zeichnen (ohne Beschriftung)
            ctx.fillStyle = 'rgba(255, 0, 0, 0.5)'; // Rot, halbtransparent
            ctx.fillRect(exitX - MARBLE_RADIUS, exitY - MARBLE_RADIUS, MARBLE_RADIUS * 2, MARBLE_RADIUS * 2);

            // Alle aktiven Murmeln zeichnen
            marbles.forEach(marble => {
                marble.draw(ctx);
            });
        }

        // Spiel-Loop: Die Hauptschleife, die das Spiel aktualisiert und neu zeichnet
        let lastFrameTime = Date.now(); // Initialisiere mit aktueller Zeit f√ºr setInterval
        let marbleIdCounter = 0; // Z√§hler f√ºr eindeutige Murmel-IDs

        /**
         * Die Hauptschleife des Spiels, die bei jedem Frame aufgerufen wird.
         * @param {number} currentTime - Der aktuelle Zeitpunkt in Millisekunden (vom Browser bereitgestellt).
         */
        function gameLoop() { // currentTime wird nicht mehr direkt von requestAnimationFrame √ºbergeben
            const currentTime = Date.now();
            const deltaTime = currentTime - lastFrameTime; // Zeit seit dem letzten Frame in Millisekunden
            lastFrameTime = currentTime;

            // Erzeuge die erste Murmel sofort, wenn noch keine da ist und das Canvas g√ºltige Dimensionen hat
            if (marbles.length === 0 && canvas.width > 0 && canvas.height > 0) {
                marbleIdCounter++;
                marbles.push(new Marble(marbleIdCounter));
                lastSpawnTime = currentTime; // Setze lastSpawnTime f√ºr die n√§chste Murmel
            }
            
            // Neue Murmel erzeugen, wenn das n√§chste Spawn-Intervall erreicht ist (nach der ersten Murmel)
            // Nur spawnen, wenn das Canvas g√ºltige Dimensionen hat
            if (marbles.length > 0 && currentTime - lastSpawnTime > nextSpawnInterval && canvas.width > 0 && canvas.height > 0) {
                marbleIdCounter++;
                marbles.push(new Marble(marbleIdCounter)); // Neue Murmel hinzuf√ºgen
                lastSpawnTime = currentTime;
                nextSpawnInterval = getRandomInt(5000, 15000); // N√§chstes Spawn-Intervall zuf√§llig festlegen
            }

            // Alle Murmeln aktualisieren
            marbles.forEach(marble => {
                marble.update(deltaTime);
            });

            // Murmeln entfernen, die zum Entfernen markiert wurden
            marbles = marbles.filter(marble => !marble.markedForRemoval);

            drawGame(); // Spiel neu zeichnen

            // requestAnimationFrame(gameLoop); // Ersetzt durch setInterval f√ºr Hintergrundausf√ºhrung
        }

        // Funktion zum Aktualisieren des Spielstands im Info-Bereich
        // Lade den Spielstand beim Start aus dem Local Storage
        let currentScore = parseInt(localStorage.getItem('gameScore')) || 0;
        const scoreDisplay = document.getElementById('score-display');

        /**
         * Aktualisiert den angezeigten Spielstand und speichert ihn lokal.
         * @param {number} newScore - Der neue Spielstand.
         */
        function updateScore(newScore) {
            currentScore = newScore;
            // Formatieren der Zahl mit Punkt als Tausendertrennzeichen
            const formattedScore = currentScore.toLocaleString('de-DE');
            if (scoreDisplay) {
                scoreDisplay.textContent = formattedScore;
            }
            // Aktualisiere den Browser-Tab-Titel
            document.title = `AM: ${formattedScore}`;
            // Speichere den aktuellen Spielstand im Local Storage
            localStorage.setItem('gameScore', currentScore.toString());

            // √úberpr√ºfe auf neue Errungenschaften
            achievementThresholds.forEach(threshold => {
                // Finde, ob diese Errungenschaft bereits aufgezeichnet wurde
                const existingAchievement = achievements.find(a => a.score === threshold);

                // Wenn der aktuelle Punktestand den Schwellenwert erreicht oder √ºberschreitet UND er noch nicht aufgezeichnet wurde
                if (currentScore >= threshold && !existingAchievement) {
                    const now = new Date();
                    // Speichere den Timestamp, um Tage seit Erreichung einfacher zu berechnen
                    const achievementTimestamp = now.getTime(); 

                    achievements.push({
                        score: threshold,
                        timestamp: achievementTimestamp // Speichere Timestamp
                    });
                    // Errungenschaften nach Punktestand sortieren
                    achievements.sort((a, b) => a.score - b.score);
                    // Errungenschaften im Local Storage speichern
                    localStorage.setItem('gameAchievements', JSON.stringify(achievements));
                    renderAchievements(); // Errungenschaftenliste neu rendern
                }
            });
        }

        /**
         * Rendert die Errungenschaftenliste im Info-Bereich.
         */
        function renderAchievements() {
            const achievementsListElement = document.getElementById('achievements-list');
            if (!achievementsListElement) return;

            achievementsListElement.innerHTML = ''; // Vorhandene Liste leeren

            achievementThresholds.forEach(threshold => {
                const row = document.createElement('tr');
                const targetCell = document.createElement('td');
                const achievedCell = document.createElement('td');

                targetCell.textContent = threshold.toLocaleString('de-DE'); // Punktestand mit Punkt formatieren
                targetCell.classList.add('py-1', 'pr-2'); // Etwas Abstand hinzuf√ºgen

                const achieved = achievements.find(a => a.score === threshold);
                if (achieved) {
                    const achievementDateObj = new Date(achieved.timestamp);
                    // Format mit Wochentag (lang)
                    const achievementDate = achievementDateObj.toLocaleDateString('de-DE', { weekday: 'long', day: '2-digit', month: '2-digit', year: 'numeric' });
                    const achievementTime = achievementDateObj.toLocaleTimeString('de-DE', { hour: '2-digit', minute: '2-digit', second: '2-digit' });

                    const daysSinceAchievement = Math.floor((Date.now() - achieved.timestamp) / (1000 * 60 * 60 * 24));
                    
                    achievedCell.textContent = `${achievementDate} ${achievementTime} (${daysSinceAchievement} Tage)`;
                    achievedCell.classList.add('text-green-400'); // Gr√ºn f√ºr erreichte Errungenschaft
                } else {
                    achievedCell.textContent = 'Noch nicht erreicht';
                    achievedCell.classList.add('text-gray-500'); // Grau f√ºr nicht erreichte Errungenschaft
                }
                achievedCell.classList.add('py-1');

                row.appendChild(targetCell);
                row.appendChild(achievedCell);
                achievementsListElement.appendChild(row);
            });
        }

        // Get modal elements
        const resetButton = document.getElementById('reset-button');
        const impressumButton = document.getElementById('impressum-button');
        const newMarbleButton = document.getElementById('new-marble-button'); // Referenz zum neuen Murmel-Button

        const resetModal = document.getElementById('reset-modal');
        const resetConfirmYes = document.getElementById('reset-confirm-yes');
        const resetConfirmNo = document.getElementById('reset-confirm-no');

        // Impressum Modal Elemente
        const impressumModal = document.getElementById('impressum-modal');
        const impressumCloseButton = document.getElementById('impressum-close');
        const impressumOkButton = document.getElementById('impressum-ok');

        // Cookie Consent Modal Elemente
        const cookieConsentModal = document.getElementById('cookie-consent-modal');
        const cookieConsentOkButton = document.getElementById('cookie-consent-ok');
        const cookieImpressumLink = document.getElementById('cookie-impressum-link');


        // Function to show the modal
        function showResetModal() {
            resetModal.classList.remove('hidden');
        }

        // Function to hide the modal
        function hideResetModal() {
            resetModal.classList.add('hidden');
        }

        // Function to show the Impressum modal
        function showImpressumModal() {
            impressumModal.classList.remove('hidden');
        }

        // Function to hide the Impressum modal
        function hideImpressumModal() {
            impressumModal.classList.add('hidden');
        }

        // Function to show the Cookie Consent modal
        function showCookieConsentModal() {
            cookieConsentModal.classList.remove('hidden');
        }

        // Function to hide the Cookie Consent modal and set local storage flag
        function hideCookieConsentModal() {
            cookieConsentModal.classList.add('hidden');
            localStorage.setItem('cookieConsentGiven', 'true'); // Merke, dass der Hinweis best√§tigt wurde
        }

        // Function to reset the game
        function resetGame() {
            // Clear local storage
            localStorage.removeItem('gameScore');
            localStorage.removeItem('gameAchievements');
            localStorage.removeItem('cookieConsentGiven'); // Auch den Cookie-Hinweis zur√ºcksetzen

            // Reset in-memory game state
            currentScore = 0;
            marbles = [];
            achievements = [];
            marbleIdCounter = 0;
            lastSpawnTime = Date.now();
            nextSpawnInterval = getRandomInt(5000, 15000); // Reset interval

            // Update UI
            updateScore(currentScore);
            renderAchievements();

            // Hide modal
            hideResetModal();
            // Optional: A full page reload might be desired for a completely fresh state
            // window.location.reload(); 
        }

        // Function to manually spawn a marble
        function spawnNewMarbleManually() {
            if (canvas.width === 0 || canvas.height === 0) {
                console.warn("Canvas not ready for spawning marbles.");
                return;
            }
            marbleIdCounter++;
            marbles.push(new Marble(marbleIdCounter));
            lastSpawnTime = Date.now(); // Update last spawn time to respect interval
        }

        // Event Listeners for Reset button and modal confirmations
        if (resetButton) {
            resetButton.addEventListener('click', showResetModal);
        }

        if (resetConfirmYes) {
            resetConfirmYes.addEventListener('click', resetGame);
        }

        if (resetConfirmNo) {
            resetConfirmNo.addEventListener('click', hideResetModal);
        }

        // Event Listener for "Neue Murmel!" button
        if (newMarbleButton) {
            newMarbleButton.addEventListener('click', () => {
                if (newMarbleButton.disabled) {
                    return; // Prevent multiple clicks while disabled
                }

                spawnNewMarbleManually(); // Spawn the marble

                // Disable button and apply visual feedback
                newMarbleButton.disabled = true;
                // Tailwind classes for disabled look are added via CSS rule :disabled
                // newMarbleButton.classList.add('opacity-50', 'cursor-not-allowed'); 

                // Re-enable button after 1 second (was 2 seconds)
                setTimeout(() => {
                    newMarbleButton.disabled = false;
                    // newMarbleButton.classList.remove('opacity-50', 'cursor-not-allowed');
                }, 1000); // Changed from 2000 to 1000 ms
            });
        }

        // Event Listeners for Impressum button and modal confirmations
        if (impressumButton) {
            impressumButton.addEventListener('click', showImpressumModal);
        }

        if (impressumCloseButton) {
            impressumCloseButton.addEventListener('click', hideImpressumModal);
        }

        if (impressumOkButton) {
            impressumOkButton.addEventListener('click', hideImpressumModal);
        }

        // Event Listeners for Cookie Consent modal
        if (cookieConsentOkButton) {
            cookieConsentOkButton.addEventListener('click', hideCookieConsentModal);
        }

        if (cookieImpressumLink) {
            cookieImpressumLink.addEventListener('click', (event) => {
                event.preventDefault(); // Verhindert das Standardverhalten des Links (Springen)
                hideCookieConsentModal(); // Cookie-Modal schlie√üen
                showImpressumModal(); // Impressum-Modal √∂ffnen
            });
        }


        // Start des Spiel-Loops, wenn das Fenster vollst√§ndig geladen ist
        window.onload = function() {
            resizeCanvas(); // Sicherstellen, dass Canvas beim Laden korrekt dimensioniert ist
            
            // Errungenschaften aus Local Storage laden
            try {
                const storedAchievements = localStorage.getItem('gameAchievements');
                if (storedAchievements) {
                    achievements = JSON.parse(storedAchievements);
                }
            } catch (e) {
                console.error("Fehler beim Laden der Errungenschaften aus localStorage:", e);
                achievements = []; // Zur√ºcksetzen, falls besch√§digt
            }

            updateScore(currentScore); // Initialen (geladenen) Punktestand anzeigen und Errungenschaften pr√ºfen
            renderAchievements(); // Initiales Rendern der Errungenschaftenliste

            // √úberpr√ºfe, ob der Cookie-Hinweis bereits best√§tigt wurde
            const cookieConsentGiven = localStorage.getItem('cookieConsentGiven');
            if (!cookieConsentGiven) {
                showCookieConsentModal(); // Zeige den Hinweis an, wenn er noch nicht best√§tigt wurde
            }

            // Starte den Spiel-Loop mit setInterval f√ºr kontinuierliche Ausf√ºhrung
            setInterval(gameLoop, 1000 / 60); // ca. 60 Frames pro Sekunde
        };
    </script>
</body>
</html>

